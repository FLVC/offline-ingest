#!/usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path(File.join(File.dirname(__FILE__), "../lib"))

require 'rubygems'
require 'offin/packages'
require 'offin/db'
require 'offin/config'
require 'watch-queue/utils'
require 'watch-queue/watch-directory'

# Note: ftp-handler is run as an independent front end for our
# queueing system, so it isn't directly running resque worker code, as
# is the ingest-handler.
#
# It *is* started and watched by the 'god' process manager (as is
# ingest-handler) however.
#
# All this is to say that our logging can be different, just writing
# to STDERR, which gets captured by the process manager and logged.

REREAD = 60 * 5   # re-read config file this often
PAUSE  = 5        # PAUSE must divide REREAD evenly

SYSTEM_ERROR_SLEEP    = 60
UNHANDLED_ERROR_SLEEP = 600

def loop_for_incoming config
  counter = 0
  wds = []
  while true
    if (counter % REREAD == 0)
      wds = watch_these_directories(config)
      if counter == 0
        STDERR.puts "INFO: reading configuration file #{config.path}"
      else
        STDERR.puts "INFO: rereading configuration file #{config.path}"
      end
    end
    wds.each { |wd| wd.enqueue_incoming_packages }
    sleep(PAUSE)
    counter += PAUSE
  end
end

# search through various stanzas for declaration of ftp_root; do
# sanity check and collect up all configs that refer to a valid
# ftp_site.

def watch_these_directories  config
  wds = []
  config.all_sections.each do |section|

    site_config = Datyl::Config.new(config.path, 'default', section)
    next unless site_config.ftp_root
    errors = ftp_directory_problems(site_config.ftp_root)

    unless errors.empty?
      STDERR.puts "ERROR: Skipping FTP configuration for #{section}, configuration errors encountered:"
      errors.each { |line| STDERR.puts "ERROR: " + line }
      next
    end
    STDERR.puts "INFO: Watching #{site_config.ftp_root} for #{section}"

    wds.push WatchDirectory.new(site_config, section)
  end
  return wds.compact
end

# A process monitor will restart an instance of this script if we exit on error.

begin
  config = setup_config()
  setup_redis_connection(config)
  setup_ingest_database(config)
  loop_for_incoming(config)
rescue Redis::CannotConnectError, SystemError => e
  STDERR.puts "ERROR: #{e.message}; sleeping for #{SYSTEM_ERROR_SLEEP} seconds."
  sleep SYSTEM_ERROR_SLEEP
  exit
rescue => e
  STDERR.puts "ERROR: #{e.class}: #{e.message}; sleeping for #{UNHANDLED_ERROR_SLEEP/60} minutes.  Backtrace follows:"
  e.backtrace.each { |line| STDERR.puts "ERROR: " + line }
  sleep UNHANDLED_ERROR_SLEEP
  exit
end
