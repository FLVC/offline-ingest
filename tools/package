#!/usr/bin/env ruby

require 'rubygems'

Kernel.trap('INT')  { STDERR.puts "Interrupt"    ; exit -2 }
Kernel.trap('HUP')  { STDERR.puts "Hangup"       ; exit -3 }
Kernel.trap('PIPE') { STDERR.puts "Pipe Closed"  ; exit -4 }

require 'socket'

case Socket.gethostname

when /alpo/
  $LOAD_PATH.unshift "/home/fischer/WorkProjects/offline-ingest/lib/"
  config_filename  = "/home/fischer/WorkProjects/offline-ingest/config.yml"

when /romeo-foxtrot/
  $LOAD_PATH.unshift "/Users/fischer/WorkProjects/offline-ingest/lib/"
  config_filename  = "/Users/fischer/WorkProjects/offline-ingest/config.yml"

when /islandorad/, /islandorat/, /islandorap/

  $LOAD_PATH.unshift "/usr/local/islandora/offline-ingest/lib/"
  config_filename  = "/usr/local/islandora/offline-ingest/config.yml"

  # TODO: move following to config

  # ENV['HTTP_PROXY'] = 'http://localhost:3128/'  # libxml picks this up, but it's very picky about syntax!
  # ENV['http_proxy'] = 'http://localhost:3128/'

else
  STDERR.puts "#{$0} Doesn't know how to configure for this environment, quitting."
  exit -1
end

require 'offin/packages'
require 'optparse'
# require 'offin/db'


def parse_command args
  server_code = []
  opts   = OptionParser.new do |opt|
    opt.banner = "Usage: package --flag package-directory < more package-directories >\n" + "where --flag is one of:\n"
    opt.on("--fsu7t",    "use fsu7t.flca.edu for ingest")          { server_code.push 'fsu7t' }
    opt.on("--fsu-prod", "use fsu-prod.flca.edu for ingest")       { server_code.push 'fsu-prod' }
    opt.on("--d7",       "use islandora7d.fcla.edu for ingest")    { server_code.push 'i7d' }
    opt.on("--alpo",     "use alasnorid.alpo.fcla.edu for ingest") { server_code.push 'alpo' }
  end
  opts.parse!(args)
  raise "No server specified."        if server_code.empty?
  raise "Too many servers specified." if server_code.length > 1
  raise "No packages specified."      if args.empty?
rescue => e
  STDERR.puts e, opts
  exit -1
else
  return server_code.pop
end

indent  = ' ' * 4
config  = Datyl::Config.new(config_filename, "default", parse_command(ARGV))
factory = PackageFactory.new(config)

$stdout.sync = true

ARGV.each do |directory|
  begin
    started = Time.now
    package = factory.new_package(directory)

    raise PackageError, "Invalid package in #{directory}." unless package.valid?

    package.updater = DigitoolMetadataUpdater
    package.ingest

    finished = Time.now
    puts sprintf('%5.2f sec, %5.2f MB  %s::%s (%s) => collection %s, "%s"',
                 finished - started,
                 package.bytes_ingested/1048576.0,
                 package.class,
                 package.name,
                 package.pid,
                 package.collections.join(', '),
                 package.label)

  rescue PackageError => e
    STDERR.puts e
  rescue => e
    STDERR.puts "Caught unexpected fatal error #{e.class} - #{e.message}", e.backtrace, '', "Please correct the error and retry."
    exit -1
  ensure
    if package
      STDERR.puts 'Errors:',   package.errors.map   { |line|  indent + line }, '' if package.errors?
      STDERR.puts 'Warnings:', package.warnings.map { |line|  indent + line }, '' if package.warnings?
    end
  end
end
